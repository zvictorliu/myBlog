# 基本管理方式

这种分配方式是将用户需要的内存空间全部分配给用户，要多少有多少，与之对应后面有不是全部分配的管理方式

分配给用户的空间有连续和非连续的区别，分成三种：

## 1 连续分配

### 1.1 单一连续

这个就是很基础很早期的，只能单一程序的时候，除了低地址的操作系统区，用户区全给一个程序，是一个不是多个

### 1.2 固定分区

在单一的基础上，把用户区分成几个段，每段给一个程序

然后要考虑的问题是：

怎么分？是均分还是不均分，对应的问题：引出*内部碎片*概念

怎么排？设置了一个叫分区说明表的记录册

### 1.3 动态分区

这里王道有说这个规划过程：刚开始一个个接着装，当放不下时，就要把前面空闲的进程给替换掉

这里有*外部碎片*的概念：替换掉前面之后，分区和分区之间就可能有一段空白了（这里的分区就是程序所需的大小，这段空白在分区外面所以叫外部，而前面是在固定分区内放一个不那么大的程序，是在分区内部）

当产生的碎片足够（多个）放入新的进程时，就需要选择哪个内存块

- 首次适应：按地址递增顺序找到的第一个
- 邻近适应：从上次查找结束位置开始
- 最佳适应：按容量递增顺序找到第一个，即容量最小的那个（而且是能满足要求的那个）
- 最坏适应：容量最大的那个

如果放进去后内存块还有剩余，就会更新大小，实际整个都是在动态维护的

## 2 基本分页式

### 2.1 基本概念

将内存和进程均分块，进程中叫`页、页面、Page`，内存中叫`页框、页帧、Page Frame`

逻辑地址由页号+页内偏移量组成，一般是高位存页号，则共可以表示$2^{20}$个页，低12位为偏移地址，即一页有$2^{12}$个单元，通常是字节为单位，所以是4KB，不过这也不一定

系统为每个进程建立一张`页表`，上面是逻辑地址到物理地址的转换，这个页表也是整个存在内存中以查找，先找到页表再去找相应的页框中存的页

一个页表项是 页号+块号，也就是说页号是页的编号，块号是页框的编号

### 2.2 地址变换

前面已经说了，寻址方式就是

首先根据逻辑地址中的页号($P = A / L$)，在页表中找对应的块号，那么怎么找到页表呢？有一个专门的页表寄存器，记录了页表的起始地址以及页表长度，后者可以用来检查是否越界

起始地址with页号就足够在内存中找到页表中的那一项了，从而得到块号

块号with偏移量能够计算出物理地址：$E = b*L + W, \quad W = A \% L$，这样的前提是<u>连续的</u>

所以有两次查找内存的过程：找页表项和找页框

为了提高速度，可以设置一个高速缓冲存储器：`快表`，在其中找页表项比访问内存要快得多，没找到再去在内存中找



因为页表也要存在连续的内存中，就比较占空间，于是设置多级页表，顶级页表只有一个页面，根据一级页号找到顶级页表，从中根据指引利用二级页号再找到块号

注意这是一种非连续的分配方式，页可以分散存在页框中，知道编号就行了，它是取消了内存分配继续性的要求



表项的数量是逻辑地址空间有多少页决定的，但也收到存页表的空间大小（一般也是一个块）和块号的位数（内存可分多少个块）

逻辑地址空间和页的大小决定逻辑地址位数

## 3 基本分段式

分段式可以不需要段与段之间连续

段表存的就不是 块号而是基地址

注意分页式计算块的物理地址并没有基地址

> 无法通过整数除法得出段号（因为段长度不固定），无法求余得到偏移，只能显式给出

共享：段表中的对应表项指向同一个物理基地址

保护：防止另一个作业修改共享段的代码，为`可重入代码`，注意它并不是临界资源

## 4 段页式

段号找到页表的基地址，跟二级有点类似
