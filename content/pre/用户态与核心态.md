# 操作系统运行环境

## 1 处理器运行模式

CPU是执行指令的，现在要给指令加权限，如果任何程序的指令都可以被直接执行的话显然是危险的

所以分了：

- 特权指令：用户不能直接执行的指令
- 非特权指令：用户可以直接使用的指令

具体实现上是通过CPU的运行模式上分为了用户态和核心态

但是，用户要完成任务必须要执行一些触及核心的指令，这就需要“委托”，注意并不是说用户指令是被编译为一条条特权指令的

那么，什么样的指令一定是定为特权指令呢？

> I/O 指令、置中断指令、寄存器相关等等

这样实际用户想做的一切都还是能被满足，意义何在？在于能够实现更安全的管理，这个挺抽象的

用户至少不是可以随意更改系统资源了，就安全得多（如果一直裸奔，那么做出危险举动谁来踩刹车呢？说明操作系统虽然是打手但也起到了监控者和管理者的作用）

本来操作系统不是必须的，只是后来把它抽象出来了

## 2 系统调用

用户需要通过系统调用来委托操作系统，操作系统提供系统调用的API

之前一直执行非特权指令的用户现在有系统调用了，现在对CPU的使用权应该给操作系统，操作系统的特权指令执行完后再把使用权还给用户

这个过程，CPU的状态经历了 用户态->核心态->用户态的过程

而具体来说是执行了陷阱指令，会掉入“陷阱”从而迫使操作系统不得不出马，以此实现切换

除此之外，CPU的切换也需要堆栈的切换，用户的堆栈和系统的堆栈不可能是同一个，但是系统堆栈也是属于该进程

## 3 中断和异常

内部叫异常，外部叫中断，而往往统称统称中断 😅

外部中断通过硬件实现，所以都是硬件中断，分可屏蔽和不可屏蔽

内部中断中也不都是软件中断，终止是硬件中断
