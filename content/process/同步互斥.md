# 同步与互斥

再次强调：

{{< hint info >}}
- 并发：一个时间段内多个任务
  - 同步：一个任务一定要先于某个任务发生
  - 互斥：不能同时访问某些资源

- 并行：同一时刻多个任务

{{< /hint >}}

`临界资源`：一次只能一个进程访问的资源，包括设备、变量等等

为了正确访问临界资源，将代码分区，访问临界资源的那部分为临界区，只有这部分是互斥执行的



一个理想的临界区互斥机制应该是：

- 空闲让进
- 忙则等待
- 有限等待：不能等待过错
- 让权等待：等待不能占用CPU，即最好不要忙等待

## 1 实现临界区互斥的软硬件方法

这个其实了解一下就够了，不是很重点

### 1.1 软件

通过设置标志，在进入临界区时检查标志，满足条件再往下执行

#### 单标志法

一个`flag`

一个标志看似足够，实则问题很大

- 只能适合交替运行，一旦另一个不再进入，自己就无法再次进入了

#### 双标志法

```python
flags = [flag_i, flag_j]
```

先检查：检查放在修改前，有可能在条件满足进入到修改自己已进入的空挡另一个进程也进入了，即检查和修改不能同时执行

后检查：检查放在修改后，这样又有可能两个几乎同时修改而使得都进入不了

#### Peterson's Algorithm

在双标志后检查法的基础上再设置一个变量turn

```c++
flag[i] = true;
turn = j;
while (flag[j] && turn == j);
```

这样就不会卡死了



软件方法无论哪种都是忙等待，仍然不够好

### 1.2 硬件

又叫低级方法、元方法

- 中断屏蔽：如果不能中断就不能进程切换，但这样就不能交替执行了，我们只是不希望两个同时在临界区而已
- 硬件指令：有一个名叫`TestAndSet`的原子指令可供调用，感觉还是忙等待；`Swap`指令

## 2 互斥锁 mutex

利用<u>原子语句</u>检查和修改

`aquire()`和`release()`

仍然是忙等待

## 3 信号量 Semaphore

也是有两个原语`wait(S)`和`signal(S)`，又可以简记为：P操作和V操作

信号量选择可以是：

- 整型变量：和布尔也差不多了
- 记录型：通过自我阻塞和对方唤醒的方法，可以实现让权等待
  - 具体来说就是发现条件不成了就主动把自己给阻塞了（不会再被调度），并且是队列的方式
  - V操作将其移出等待队列，也就算是唤醒了

P一次一定会减一，不一定阻塞，所以如果S小于0则代表当前有几个进程在等待队列中

### 3.1 实现同步

A在最后V，B先P，S初值为0，这样就是B等A

### 3.2 实现互斥

每一个进入前P，离开后V，并且S初值为1，这样就会有一个抢到的

### 3.3 实现前驱



## 4 管程方法



## 5 经典同步问题

### 5.1 生产-消费模型

只能一个写，只能一个读

### 5.2 读者-写者模型

只能一个写，可以多个读

### 5.3 哲学家进餐



### 5.4 吸烟者问题

