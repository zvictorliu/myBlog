---
title: 死锁
---

# 死锁

多个进程竞争资源造成了一种僵局，使得互相等待，陷入死循环

死锁的必要条件

- 互斥条件：某一资源只能互斥访问
- 不剥夺条件（非抢占）：只能主动释放
- 请求并保持条件：进程已经占了一个资源，并请求另一个被占的资源，此时进程被阻塞但是并没有释放资源
- 循环等待条件：循环等待链关系，占用的资源总被环上下一个所请求，并且只能是自己释放才能满足它，如果还有别的进程释放了、又或者不只一台设备，也不会构成死锁

​		<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230527163242757.png" alt="image-20230527163242757" style="zoom:67%;" />

所以，对死锁的策略：

- 预防：限制其出现必要条件中的几个
- 避免（其实也是一种预防了）
- 检测并解除

## 1 预防

破坏四个必要条件之一

- 互斥：不太可行，因为有些资源是无法共享的，只能互斥
- 非抢占：实现起来比较麻烦
- 请求并保持：一次申请完并占用，之后不再请求，比较浪费
- 循环等待：按顺序分配

## 2 避免

并不是事先预防，是动态检测资源分配的状态

### 2.1 安全检查

允许进程随时申请，但是系统在分配之前会先进行计算安全性，不安全就先让进程等待

需要找到一种`安全序列`

{{< details title="例题" open=true >}}

![image-20230527165425149](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230527165425149.png)

{{< /details >}}

注意不安全不代表一定会死锁，只是有可能死锁

### 2.2 银行家算法

决定要不要分配的算法
{{< tabs "数据结构" >}}
{{< tab "可利用资源向量" >}} 记录第i类资源的可用数目 {{< /tab >}}
{{< tab "最大需求矩阵" >}} 每个进程对每类资源的最大需求 {{< /tab >}}
{{< tab "分配矩阵" >}} 实际已经分配的情况 {{< /tab >}}
{{< tab "需求矩阵" >}} Max - Allocation，表示接下来最多还要多少 {{< /tab >}}
{{< /tabs >}}

具体算法是：

定义请求向量，即某个进程此时对各类资源的申请数量

1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求 
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

能通过检查就分配，否则让其等待

而安全性算法：

前面说了是试探性分配，用修改后的数据来，令work = available

- 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收（修改work）
- 不断重复上述过程，看最终是否能让所有进程都加入安全序列


## 3 检测和解除

如果不预防和避免，那就应该能够检测到并解除

维护一张资源分配图：

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230527172240284.png" alt="image-20230527172240284" style="zoom:67%;" />



然后进行简化：见王道P145

当不可完全简化时，就是死锁了，这叫*死锁定理*

解除的方法：

- 剥夺抢占
- 撤销进程
- 进程回退
