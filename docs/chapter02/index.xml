<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>进程 on Operating System</title>
    <link>https://zvictorliu.github.io/myBlog/chapter02/</link>
    <description>Recent content in 进程 on Operating System</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://zvictorliu.github.io/myBlog/chapter02/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/myBlog/chapter02/process_concept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/myBlog/chapter02/process_concept/</guid>
      <description></description>
    </item>
    
    <item>
      <title>进程通信</title>
      <link>https://zvictorliu.github.io/myBlog/chapter02/ipc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/myBlog/chapter02/ipc/</guid>
      <description>有些进程是完全独立的，自成一派，而有些则是协作进程，会受到其它进程的影响，比如：共享资源可能会被其它进程所修改
进程通信 (InterProcess Communication, IPC) 机制就是用于进程间交互的一套规则
进程通信有两种基本的形式：
共享内存，好比网盘传输 消息传递，好比文件传输助手 共享内存系统#一个共享区域应该这样产生：一个进程（生产者）创建共享内存段，这段空间被加到另一个进程（消费者）的地址空间内
有两个注意的问题：
操作系统一般会限制进程只访问自己的地址空间 即使是共享的，也不能同时写，有可能发生冲 在生产-消费关系里面，消费者可以在生产者写的同时，读取已经写过的区域 这段缓冲区可以是无界的，生产者可以一直生产放进无底洞，也可以是有界的，仓库满了生产者就必须要等消费者取走以腾出位置（假设知道读写状态）
消息传递系统#两个进程之间能够互相发送和接收消息
要认识到通信需要存在一种“电话线”，将二者连接起来，这和广播不同，进程通信的电话线叫做链路
一般来说发送消息需要指明对象，可是如果对方改电话号码了呢？要知道进程的标识符是可以被改变的
有一种间接通信方案，那就是“基站”，一般是邮箱或端口，这个和共享内存的区别在于基站并非是地址空间的一部分
基站的问题是无法限制在两个进程之间，还可以有第三个第四个，那么就要有所选择谁能收到消息
注意这两个名词的含义
同步：阻塞模式 发送时有人接收才能完成 持续等待知道有消息来 异步：非阻塞 发出去就完事，对方收没收到不管 读取一个消息，可能是有效的也可能是空 如果生产者和消费者是同步的，那么两者之间就建立了交会 rendezvous
再说这个基站，它应是一个缓存区
几种操作系统的IPC实例#POSIX系统 API Mach操作系统 Windows系统 与之类似的客户机/服务器的通信#套接字：网络 远程过程调用（RPC） 管道 </description>
    </item>
    
  </channel>
</rss>
