<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>文件管理 on Operating System</title>
    <link>https://zvictorliu.github.io/myBlog/file_management/</link>
    <description>Recent content in 文件管理 on Operating System</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://zvictorliu.github.io/myBlog/file_management/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>文件</title>
      <link>https://zvictorliu.github.io/myBlog/file_management/%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/myBlog/file_management/%E6%96%87%E4%BB%B6/</guid>
      <description>文件#要明确文件不只是数据项（虽然其它信息本质也是数据）
文件除了数据，还会记录与文件相关的信息，叫做文件元数据，其实就是文件属性的意思
包括名称、类型、位置、大小、创建时间等信息
1 文件控制块FCB#一个FCB是一种数据结构，保存了用于控制文件所需的各种信息，它是用来管理的，不是文件本身（图里面的文件数据块不知道是啥）
按照一定顺序，各个FCB放在文件目录中，一个FCB和一个文件名对应
查找文件的基本流程是：将磁盘分多个盘块，每个盘块有多个FCB，查找时把第一个盘块中的目录调入内存和文件名比较，没找到就换下一个盘块
如果盘块中目录项太少就会访问磁盘很多次，所以不好把整个FCB都存入盘块中
由于查找文件时只需要文件名比对，所以将文件的描述信息剥离开，形成一个索引节点
每个目录项只包含文件名和指向索引节点的指针，这样一个目录项就会小很多，一个盘块也能容纳更多目录项
存放在磁盘上的索引节点 当文件被打开时将它复制到内存中并增加一些信息，成为内存索引节点（这里的命名是根据存放的位置）
2 文件打开与关闭#基本操作包括：
创建 写 读 重新定位 删除 截断 文件需要显示地被打开，显示调用之后放入内存，之后就找的快
调用open，先根据提供的文件路径找到目录文件 在目录文件中找到和文件名一致的目录项 检查操作权限是否具备 将该目录项（索引）复制到内存中一个记录当前已打开文件的表中（因为往往不只打开一个文件） 之后，再次对文件发出操作请求时，可在内存中的表内找到文件信息
具体来说，应该是两个表，一个是每个进程的打开表，一个是记录所有进程的打开表（系统表）
如果一个进程打开前面一个进程已经打开的文件，就只需要把指针指向这个系统表
而关闭，则通过一个记录文件关联的进程个数的计数器，计数值为0则代表均已声明了关闭，于是操作系统才算真正关闭它
打开文件表的索引不一定是文件名，不同操作系统有不同的设置
打开表应该在索引节点基础之上包含：
文件指针：这个并不是指向文件物理位置的指针，而是记录上次读写的位置 文件打开计数 文件磁盘位置 访问权限 这些都是和进程关系起来的
3 文件保护#谈一谈那个权限的信息了
其实也不光是防着越权，还有记录访问方式的，这个在编程时很有体会，r w wb 这些就是表示是给什么操作，说好是只读的不能写（这个只读不是文件本身锁死了只读，是进程申请打开时就说的只读，如果后面写的话就是违规的）
口令保护 加密保护：真的是对文件进行了加密，通过密码解密 访问控制 4 文件物理结构##别忘了磁盘也是分块的
连续分配：每个文件占连续的块
链接分配：指针连接走到底便是完整的文件
隐式链接 显示链接 索引分配
FAT占内存，所以将该文件所对应盘块编号放在一起，目录查找到它就行了
混合索引分配
5 文件逻辑结构#呈现给用户的结构</description>
    </item>
    
    <item>
      <title>文件系统</title>
      <link>https://zvictorliu.github.io/myBlog/file_management/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/myBlog/file_management/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>文件系统#应用程序通过文件系统和磁盘交互
具有层次结构：
说来就是操作系统了？
1 文件系统布局#1.1 在磁盘上#文件系统存在磁盘上，磁盘分区，每个分区有一个独立的文件系统
MBR: 主引导记录，引导计算机，BIOS读入MBR并执行，确定活动分区，即引导块
引导块：执行引导块的程序，启动操作系统，在此之后布局就不一定一样了，和文件系统有关系
超级块：包含了文件系统的信息，启动时或者首次使用文件系统时调入内存
空闲块信息
1.2 在内存中#保存信息数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃
安装表：已安装文件系统分区的信息 目录结构缓存 系统打开文件表 进程打开文件表 2 外存空闲空间管理#磁盘中包含文件系统的分区叫做卷(volume)
一个磁盘可以有多个卷，也可以一个磁盘本身就是一个卷，甚至多个磁盘构成一个卷
文件存储设备也是分块的，管理起来也就是对空闲块的管理：组织、分配、回收
空闲表法
空闲链表法
位示图法
成组链接法
3 虚拟文件系统#统一接口，统一调用VFS提供的函数操作不同的文件系统和存储介质
面向对象设计
4 分区和安装#</description>
    </item>
    
    <item>
      <title>目录</title>
      <link>https://zvictorliu.github.io/myBlog/file_management/%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/myBlog/file_management/%E7%9B%AE%E5%BD%95/</guid>
      <description>目录#FCB的有序集合为文件目录，一个FCB就是一个文件目录项
（说是这么说，之前好像说不是整个FCB 🤔 索引节点是一种FCB改进
目录提供 文件名和文件的映射，按名存取
目录的检索速度影响性能 多用户系统应该允许重名，单用户则不能 有四种结构，一般是树形结构
1 目录结构#1.1 单级目录结构#一张目录表，一个文件占一个目录项
查找：根据文件名找到对应的FCB，检查合法后进行操作
创建：先检索所有目录以确保没有重名，然后再添加一项
删除：先找到目录项，回收文件的存储空间，然后再删除FCB
1.2 两级目录结构#分成主文件目录和用户文件目录
这样就可以不同用户重名
为何说提高效率，且用户不能对文件分类？
1.3 树形目录结构#这个是我们熟悉的结构
绝对目录和相对目录
原来分类是这个意思
缺点是：查找文件需要逐级访问中间节点，增加了磁盘访问次数
大多数操作系统都是树形结构目录
1.4 无环图目录结构#为便于实现文件共享
增加了有向边指向共享的节点（可以是文件，也可以是目录，而且两边还可以不同名）
并设置了一个共享计数器，为0时才算真正删除，否则只是删除一个用户的链接关系
2 文件共享#共享不同于拷贝，现代有两种常用共享办法
2.1 硬链接#就是1.4的思想，具体来说是通过索引结点实现的，计数器保存至文件的索引节点当中
计数器更新：
这里面其实是有：A共享给B，所以owner还是A
2.2 软链接#给B创建一个LINK类型的文件，B访问共享文件找到LINK，操作系统将其转到共享文件，这样只有A的指针指向了索引节点，这种叫做符号链接
这样A删除文件，B的LINK就找不到会被操作系统删除而不产生影响
硬链接查找速度比软链接块</description>
    </item>
    
  </channel>
</rss>
