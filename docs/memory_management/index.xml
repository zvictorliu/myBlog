<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>内存管理 on Operating System</title>
    <link>https://zvictorliu.github.io/operating_system/memory_management/</link>
    <description>Recent content in 内存管理 on Operating System</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://zvictorliu.github.io/operating_system/memory_management/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://zvictorliu.github.io/operating_system/memory_management/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/operating_system/memory_management/basic/</guid>
      <description>基本管理方式#这种分配方式是将用户需要的内存空间全部分配给用户，要多少有多少，与之对应后面有不是全部分配的管理方式
分配给用户的空间有连续和非连续的区别，分成三种：
1 连续分配#1.1 单一连续#这个就是很基础很早期的，只能单一程序的时候，除了低地址的操作系统区，用户区全给一个程序，是一个不是多个
1.2 固定分区#在单一的基础上，把用户区分成几个段，每段给一个程序
然后要考虑的问题是：
怎么分？是均分还是不均分，对应的问题：引出内部碎片概念
怎么排？设置了一个叫分区说明表的记录册
1.3 动态分区#这里王道有说这个规划过程：刚开始一个个接着装，当放不下时，就要把前面空闲的进程给替换掉
这里有外部碎片的概念：替换掉前面之后，分区和分区之间就可能有一段空白了（这里的分区就是程序所需的大小，这段空白在分区外面所以叫外部，而前面是在固定分区内放一个不那么大的程序，是在分区内部）
2 基本分页式#2.1 基本概念#将内存和进程均分块，进程中叫页、页面、Page，内存中叫页框、页帧、Page Frame
逻辑地址由页号+页内偏移量组成，一般是高位存页号，则共可以表示$2^{20}$个页，低12位为偏移地址，即一页有$2^{12}$个单元，通常是字节为单位，所以是4KB，不过这也不一定
系统为每个进程建立一张页表，上面是逻辑地址到物理地址的转换，这个页表也是整个存在内存中以查找，先找到页表再去找相应的页框中存的页
一个页表项是 页号+块号，也就是说页号是页的编号，块号是页框的编号
2.2 地址变换#前面已经说了，寻址方式就是
首先根据逻辑地址中的页号($P = A / L$)，在页表中找对应的块号，那么怎么找到页表呢？有一个专门的页表寄存器，记录了页表的起始地址以及页表长度，后者可以用来检查是否越界
起始地址with页号就足够在内存中找到页表中的那一项了，从而得到块号
块号with偏移量能够计算出物理地址：$E = b*L + W, \quad W = A % L$，这样的前提是连续的
所以有两次查找内存的过程：找页表项和找页框
为了提高速度，可以设置一个高速缓冲存储器：快表，在其中找页表项比访问内存要快得多，没找到再去在内存中找
因为页表也要存在连续的内存中，就比较占空间，于是设置多级页表，顶级页表只有一个页面，根据一级页号找到顶级页表，从中根据指引利用二级页号再找到块号
3 基本分段式#分段式可以不需要段与段之间连续
段表存的就不是 块号而是基地址
注意分页式计算块的物理地址并没有基地址
4 段页式#段号找到页表的基地址，跟二级有点类似</description>
    </item>
    
    <item>
      <title>前置知识</title>
      <link>https://zvictorliu.github.io/operating_system/memory_management/pre/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/operating_system/memory_management/pre/</guid>
      <description>前置基础#1 链接和装入#源程序变成可执行文件的过程：
可执行文件要被调入内存种才能执行，这个过程叫装入
链接有三种方式：
装入也有三种方式
2 地址#逻辑地址：编译后每个模块都是从0开始编址的相对地址
而链接程序将两个模块合并时就需要修改相对地址，但也只是相对一个0，还是相对地址
内存运行计算时直接使用的也还是逻辑地址
逻辑地址经过地址变换转为物理地址才能在内存种找到相应的位置，这叫地址重定位
具体来说是有一种页表，它记录了对应关系，由操作系统维护，处理器使用它
3 内存映像#程序调入内存并运行，形成了进程在的内存种的实体，这个叫内存映像，实体=映像
具体来说分成几段：
代码段、数据段 PCB，没错之前说的PCB就是保存在内存中 堆：存放动态分配的变量 栈：用以实现函数调用，从高向低增长 比如第一个进程如果完整放入内存应该是这样子：
内存映像4 内存保护、共享#就是避免越界访问，需要一个检查装置
&amp;hellip;</description>
    </item>
    
    <item>
      <title>虚拟内存</title>
      <link>https://zvictorliu.github.io/operating_system/memory_management/virtual_memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/operating_system/memory_management/virtual_memory/</guid>
      <description>先知道一下局部性原理
虚拟存储器的思想是：
作业只先把当前需要的那部分程序和数据装入内存，当运行到没有的时，再次装入 将暂时不用的部分换出去，需要时再换进来 内存能装入的进程变多，逻辑上空间变大 为实现虚拟存储器，有三种方式：
请求分页（最主要）、请求分段、请求段页 和前面的基本xxx相比，这属于”请求“，这个是特点
只学请求分页
1 请求分页管理方式#能实现调入所需页面、置换暂时不需要的页面
需要的硬件支持：
页表 缺页中断：想来真tm合理 地址变换 1.1 页表#多增加了几个字段的原因：
为实现请求，需要知道页面当前在不在内存中，同时还需要知道在外存中的位置 有点忘了基本分页为什么不需要外存地址了，，，，， 内存不够需要置换时，需要有依据决定哪些是可以换出去的，此外，如果页面没有被修改过的话就不需要再将其写一遍到外存，因此还有一个记录是否被修改的 所以，多出来了四个字段：
1.2 缺页中断#页面不在内存，就产生中断，为的是请求操作系统来把需要的页调入内存
在等待操作系统完成时，将该进程阻塞，完成后再唤醒放入就绪队列
如果没有空闲块就需要进行淘汰换出了
这种中断的特点是：
是内部异常，在指令执行期间产生和处理
类似于”找不到文件“的异常 一条指令可能有多次缺页中断
1.3 地址变换#程序请求访问一页，需要经过地址变换得到在内存中的物理地址，这个过程其实经历了许许多多if else的判断
基本分页方式都认为页就在内存当中，所以不会有请求调入和页面置换这两个步骤
会先检索快表（这个忘了）
2 页面置换算法#很简单就是如何选择哪个该换出去的算法，有四种
最佳置换OPT 先进先出FIFO 最近最久未使用LRU 时钟 2.1 OPT#2.2 FIFO#2.3 LRU#2.4 Clock#简单型和改进型
3 页面分配策略#页框是内存的”页“，这节研究给特定的进程分配多少页框，很类似于内存的划分了
太少了，虽然能放的进程多了，但每个进程缺页的概率很高（即使有局部性原理）
太多了，由于局部性原理可能根本不需要很多，缺页率不会降低太多
这部分感觉不是重点，但是也可能考，，，所以，，唉</description>
    </item>
    
  </channel>
</rss>
